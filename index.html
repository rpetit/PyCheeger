

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>PyCheeger &mdash; PyCheeger 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> PyCheeger
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">PyCheeger</a></li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">PyCheeger</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>PyCheeger</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pycheeger.compute_cheeger">
<span id="pycheeger"></span><h1>PyCheeger<a class="headerlink" href="#module-pycheeger.compute_cheeger" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="pycheeger.compute_cheeger.compute_cheeger">
<code class="sig-prename descclassname"><span class="pre">pycheeger.compute_cheeger.</span></code><code class="sig-name descname"><span class="pre">compute_cheeger</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tri_area_fm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter_fm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_results_fm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_boundary_vertices_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tri_area_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence_tol_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter_resampling_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_results_ld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.compute_cheeger.compute_cheeger" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cheeger set associated to the weight function eta</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eta</strong> (<em>function</em>) – Function to be integrated. f must handle array inputs with shape (N, 2)</p></li>
<li><p><strong>max_tri_area_fm</strong> (<em>float</em>) – Fixed mesh step parameter. Maximum triangle area allowed for the domain mesh</p></li>
<li><p><strong>max_iter_fm</strong> (<em>int</em>) – Fixed mesh step parameter. Maximum number of iterations for the primal dual algorithm</p></li>
<li><p><strong>plot_results_fm</strong> (<em>bool</em>) – Fixed mesh step parameter. Whether to plot the results of the fixed mesh step or not</p></li>
<li><p><strong>num_boundary_vertices_ld</strong> (<em>int</em>) – Local descent step parameter. Number of boundary vertices used to represent the simple set</p></li>
<li><p><strong>max_tri_area_ld</strong> (<em>float</em>) – Local descent step parameter. Maximum triangle area allowed for the inner mesh of the simple set</p></li>
<li><p><strong>step_size_ld</strong> (<em>float</em>) – Local descent step parameter. Step size used in the local descent</p></li>
<li><p><strong>max_iter_ld</strong> (<em>int</em>) – Local descent step parameter. Maximum number of iterations allowed for the local descent</p></li>
<li><p><strong>convergence_tol_ld</strong> (<em>float</em>) – Local descent step parameter. Convergence tol for the local descent</p></li>
<li><p><strong>num_iter_resampling_ld</strong> (<em>None</em><em> or </em><em>int</em>) – Local descent step parameter. Number of iterations between two resampling of the boundary curve (None for no
resampling)</p></li>
<li><p><strong>plot_results_ld</strong> (<em>bool</em>) – Local descent step parameter. Whether to plot the results of the local descent step or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>simplet_set</strong> (<em>SimpleSet</em>) – Cheeger set</p></li>
<li><p><strong>obj_tab</strong> (<em>array, shape (n_iter_ld,)</em>) – Values of the objective over the course of the local descent</p></li>
<li><p><strong>grad_norm_tab</strong> (<em>array, shape (n_iter_ld,)</em>) – Values of the objective gradient norm over the course of the local descent</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pycheeger.simple_set"></span><dl class="py class">
<dt id="pycheeger.simple_set.SimpleSet">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">pycheeger.simple_set.</span></code><code class="sig-name descname"><span class="pre">SimpleSet</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boundary_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tri_area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple set</p>
<dl class="py attribute">
<dt id="pycheeger.simple_set.SimpleSet.boundary_vertices">
<code class="sig-name descname"><span class="pre">boundary_vertices</span></code><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.boundary_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Each row contains the two coordinates of a boundary vertex</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (N, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.simple_set.SimpleSet.num_boundary_vertices">
<code class="sig-name descname"><span class="pre">num_boundary_vertices</span></code><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.num_boundary_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of boundary vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.simple_set.SimpleSet.is_clockwise">
<code class="sig-name descname"><span class="pre">is_clockwise</span></code><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.is_clockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the list of boundary vertices is clockwise ordered or not</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.simple_set.SimpleSet.mesh_vertices">
<code class="sig-name descname"><span class="pre">mesh_vertices</span></code><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.mesh_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Each row contains the two coordinates of a vertex of the simplet set inner mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (M, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.simple_set.SimpleSet.mesh_faces">
<code class="sig-name descname"><span class="pre">mesh_faces</span></code><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.mesh_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Each row contains the three indices describing a face of the simple set inner mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (K, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.simple_set.SimpleSet.boundary_faces_indices">
<code class="sig-name descname"><span class="pre">boundary_faces_indices</span></code><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.boundary_faces_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>One dimensional array, contains the indices of the boundary faces of the simple set inner mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.compute_perimeter">
<code class="sig-name descname"><span class="pre">compute_perimeter</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.compute_perimeter" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the perimeter of the set</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The perimeter</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.compute_perimeter_gradient">
<code class="sig-name descname"><span class="pre">compute_perimeter_gradient</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.compute_perimeter_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “gradient” of the perimeter</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Each row contains the two coordinates of the translation to apply at each boundary vertex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array, shape (N, 2)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See <a href="#id7"><span class="problematic" id="id1">[1]_</span></a> (first variation of the perimeter)</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">1</span></dt>
<dd><p>Maggi, F. (2012). Sets of finite perimeter and geometric variational problems: an introduction to
Geometric Measure Theory (No. 135). Cambridge University Press.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.compute_weighted_area">
<code class="sig-name descname"><span class="pre">compute_weighted_area</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.compute_weighted_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral of f over the set</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>function</em>) – Function to be integrated. f must handle array inputs with shape (N, 2). It can be vector valued</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Value computed for the integral of f over the set (if f takes values in dimension D, the result will be an
array of shape (D,))</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or array of shape (D,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.compute_weighted_area_gradient">
<code class="sig-name descname"><span class="pre">compute_weighted_area_gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.compute_weighted_area_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “gradient” of the weighted area, for a given weight function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>function</em>) – Function to be integrated. f must handle array inputs with shape (N, 2). It can be vector valued</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Vectorized computations are really nasty here, mainly because f can be vector valued.</p>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.compute_weighted_areas">
<code class="sig-name descname"><span class="pre">compute_weighted_areas</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.compute_weighted_areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral of f on each face of the inner mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>function</em>) – Function to be integrated. f must handle array inputs with shape (N, 2). It can be vector valued</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Value computed for the integral of f on each of the N triangles (if f takes values in dimension D, the shape
of the resulting array is (N, D))</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,) or (N,D)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.contains">
<code class="sig-name descname"><span class="pre">contains</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether a given point x is inside the set or not</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em>) – The input point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether x is in the set or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.mesh">
<code class="sig-name descname"><span class="pre">mesh</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_tri_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the inner mesh of the set</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_tri_area</strong> (<em>float</em>) – Maximum triangle area for the inner mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.simple_set.SimpleSet.resample_boundary">
<code class="sig-name descname"><span class="pre">resample_boundary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tri_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.SimpleSet.resample_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the boundary of the simple set, and creates a new inner mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_points</strong> (<em>int</em>) – Number of points in the resampled boundary</p></li>
<li><p><strong>max_tri_area</strong> (<em>float</em>) – Maximum triangle area for the new inner mesh</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pycheeger.simple_set.disk">
<code class="sig-prename descclassname"><span class="pre">pycheeger.simple_set.</span></code><code class="sig-name descname"><span class="pre">disk</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tri_area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.simple_set.disk" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a SimpleSet with boundary vertices regularly spaced on a circle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em>) – Coordinates of the center</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the circles</p></li>
<li><p><strong>num_vertices</strong> (<em>int</em>) – Number of boundary vertices (on the disk)</p></li>
<li><p><strong>max_tri_area</strong> (<em>None</em><em> or </em><em>float</em>) – Maximum area allowed for triangles, see Shewchuk’s Triangle mesh generator, defaut None (no constraint)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pycheeger.simple_set.SimpleSet" title="pycheeger.simple_set.SimpleSet">SimpleSet</a></p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pycheeger.mesh"></span><dl class="py class">
<dt id="pycheeger.mesh.Mesh">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">pycheeger.mesh.</span></code><code class="sig-name descname"><span class="pre">Mesh</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw_mesh</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom mesh class</p>
<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.vertices">
<code class="sig-name descname"><span class="pre">vertices</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Each row contains the two coordinates of a vertex</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (N, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.faces">
<code class="sig-name descname"><span class="pre">faces</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Each row contains the three indices of the face’s vertices. For convenience reasons, the values in each row are
sorted, i.e. the face whose vertices have indices 0, 1, 2 will always be stored as [0, 1, 2] (and not [1, 0, 2])</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (M, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.edges">
<code class="sig-name descname"><span class="pre">edges</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Each row contains the two indices of the edge’s vertices. For convenience reasons, the values in each row are
sorted, i.e. the edge whose vertices have indices 0, 1 will always be stored as [0, 1] (and not [1, 0])</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (K, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.num_edges">
<code class="sig-name descname"><span class="pre">num_edges</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.num_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Equals K</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.num_faces">
<code class="sig-name descname"><span class="pre">num_faces</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.num_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Equals M</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.num_vertices">
<code class="sig-name descname"><span class="pre">num_vertices</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Equals N</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="pycheeger.mesh.Mesh.grad_mat">
<code class="sig-name descname"><span class="pre">grad_mat</span></code><a class="headerlink" href="#pycheeger.mesh.Mesh.grad_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear operator mapping a vector of length M (the values taken by a piecewise constant function on the mesh) to
a vector of length K (the jumps / values taken by the gradient on each edge of the mesh)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>scipy.sparse.csr_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.build_grad_matrix">
<code class="sig-name descname"><span class="pre">build_grad_matrix</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.build_grad_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient matrix associated to the mesh</p>
<p>The gradient is the linear operator mapping a vector of length M (the values taken by a piecewise constant
function on the mesh) to a vector of length K (the jumps / values taken by the gradient on each edge of the
mesh), M being the number of faces in the mesh, and K being the number of edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The gradient matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.sparse.csr_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.get_edge_adjacent_faces">
<code class="sig-name descname"><span class="pre">get_edge_adjacent_faces</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.get_edge_adjacent_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of all faces to which a given edge belongs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em>) – Array containing two integers, which are the indices of the edge’s vertices. Does not need to be sorted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>One dimensional integer valued array containing the indices of the relevant faces</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.get_edge_index">
<code class="sig-name descname"><span class="pre">get_edge_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.get_edge_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of an edge given by its two vertices in the array of edges</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em>) – Array containing two integers, which are the indices of the edge’s vertices. Does not need to be sorted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The index of the input edge (raises an error if the edge is not found or found multiple times)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.get_edge_length">
<code class="sig-name descname"><span class="pre">get_edge_length</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.get_edge_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the euclidean distance between the two vertices of an edge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> (<em>array</em><em>, </em><em>shape</em><em>(</em><em>2</em><em>,</em><em>)</em>) – Array containing two integers, which are the indices of the edge’s vertices. Does not need to be sorted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The length of the edge</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.get_face_area">
<code class="sig-name descname"><span class="pre">get_face_area</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.get_face_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the area of a face</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>face_index</strong> (<em>int</em>) – Index of the face in self.faces</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Area of the input face</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.get_face_edges">
<code class="sig-name descname"><span class="pre">get_face_edges</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.get_face_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of edges which belong to a given face</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>face_index</strong> (<em>int</em>) – The index of the face in self.faces</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Each row contains the two indices of an edge’s vertices (sorted).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (3, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.get_orientation">
<code class="sig-name descname"><span class="pre">get_orientation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.get_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the orientation of an edge with respect to a given face.</p>
<p>The orientation of an edge with respect to a face is defined as +1 if the normal is the outward normal and -1
otherwise. The normal is computed by applying a counter clockwise rotation to the edge vector, which is himself
given by v2 - v1 where v1 and v2 are the two vertices of the edge, and the index of v1 in self.vertices is
smaller than the one of v2 (edges are always stored sorted). This definition of the orientation is of course
arbitrary, but the only thing we need is to keep one that is consistent all along.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>face_index</strong> (<em>int</em>) – Index of the face in self.faces</p></li>
<li><p><strong>edge</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em>) – Array containing two integers, which are the indices of the edge’s vertices. Does not need to be sorted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>+1 or -1 if the input face contains the input edge (see the explanations above), and 0 otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pycheeger.mesh.Mesh.integrate">
<code class="sig-name descname"><span class="pre">integrate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.mesh.Mesh.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral of a given function on each face of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>function</em>) – Function to be integrated. f must handle array inputs with shape (N, 2), N being the number of faces of the
mesh. It can be vector valued</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Value computed for the integral of f on each of the N triangles (if f takes values in dimension D, the shape
of the resulting array is (N, D))</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,) or (N, D)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pycheeger.tools"></span><dl class="py function">
<dt id="pycheeger.tools.find_threshold">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">find_threshold</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.find_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the Lagrange multiplier involved in the projection of x into the unit l1 ball</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em>) – Vector to be projected</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – Value of the Lagrange multiplier</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Sorting based algorithm. See <a href="#id8"><span class="problematic" id="id3">[1]_</span></a> for a detailed explanation of the computations and alternative algorithms.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets">1</span></dt>
<dd><p>L. Condat, <em>Fast Projection onto the Simplex and the l1 Ball</em>, Mathematical Programming,
Series A, Springer, 2016, 158 (1), pp.575-585.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.integrate_on_triangles">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">integrate_on_triangles</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.integrate_on_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical integration of f on a list of triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function</em>) – Function to be integrated. f must handle array inputs with shape (N, 2). It can be vector valued</p></li>
<li><p><strong>triangles</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>, </em><em>3</em><em>, </em><em>2</em><em>)</em>) – triangles[i, j] contains the coordinates of the j-th vertex of the i-th triangle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Value computed for the integral of f on each of the N triangles (if f takes values in dimension D, the shape of
the resulting array is (N, D))</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,) or (N, D)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, quadpy is only used to extract the scheme’s characteristics, in order to speed up computations (in quadpy,
the code handles arbitrary dimensions and is too generic)</p>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.postprocess_indicator">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">postprocess_indicator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_mat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.postprocess_indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Post process a piecewise constant function on a mesh to get an indicator function of a union of cells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em>) – Values describing the piecewise constant function to be processed</p></li>
<li><p><strong>grad_mat</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>M</em><em>, </em><em>N</em><em>)</em>) – Matrix representing the linear operator which maps the values describing a piecewise constant function to its
jumps on each edge of the mesh</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Values of the indicator function on each cell of the mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.proj_unit_l1_ball">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">proj_unit_l1_ball</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.proj_unit_l1_ball" title="Permalink to this definition">¶</a></dt>
<dd><p>Projection onto the l1 unit ball</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em>) – Vector to be projected</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – Projection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See <a href="#id9"><span class="problematic" id="id5">[1]_</span></a> for a detailed explanation of the computations and alternative algorithms.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">1</span></dt>
<dd><p>L. Condat, <em>Fast Projection onto the Simplex and the l1 Ball</em>, Mathematical Programming,
Series A, Springer, 2016, 158 (1), pp.575-585.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.prox_dot_prod">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">prox_dot_prod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.prox_dot_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal map of the inner product between x and a</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em>) – </p></li>
<li><p><strong>tau</strong> (<em>float</em>) – </p></li>
<li><p><strong>a</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.prox_inf_norm">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">prox_inf_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.prox_inf_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal map of the l-infinity norm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em>) – </p></li>
<li><p><strong>tau</strong> (<em>float</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[prox_{\tau \, ||.||_{\infty}}(x) = x - \tau ~ \text{proj}_{\{||.||_{\infty}\leq 1\}}(x / \tau)\]</div>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.resample">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">resample</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curve</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample a closed polygonal chain</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>curve</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>, </em><em>2</em><em>)</em>) – Curve to be resampled, described by the list of its vertices. The last vertex should not be equal to the first
one (the input array should be a minimal description of the closed polygonal chain)</p></li>
<li><p><strong>num_points</strong> (<em>int</em>) – Number of vertices of the output curve</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Resampled curve</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (num_points, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.run_primal_dual">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">run_primal_dual</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta_bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_mat_norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.run_primal_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the “fixed mesh weighted Cheeger problem” by running a primal dual algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#pycheeger.mesh.Mesh" title="pycheeger.mesh.Mesh"><em>Mesh</em></a>) – Triangle mesh made of N triangles and M edges</p></li>
<li><p><strong>eta_bar</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>, </em><em>2</em><em>)</em>) – Integral of the weight function on each triangle</p></li>
<li><p><strong>max_iter</strong> (<em>integer</em>) – Maximum number of iterations (for now, exact number of iterations, since no convergence criterion is
implemented yet)</p></li>
<li><p><strong>grad_mat_norm</strong> (<em>float</em>) – Norm of the gradient operator for piecewise constant functions on the mesh</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>defaut False</em>) – Whether to print some information at the end of the algorithm or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Values describing a piecewise constant function on the mesh, which solves the fixed mesh weighted Cheeger problem</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (N, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.triangulate">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">triangulate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_triangle_area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangulate the interior of a closed polygonal curve using the triangle library (Python wrapper around Shewchuk’s
Triangle mesh generator)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>, </em><em>2</em><em>)</em>) – Coordinates of the curve’s vertices</p></li>
<li><p><strong>max_triangle_area</strong> (<em>None</em><em> or </em><em>float</em>) – Maximum area allowed for triangles, see Shewchuk’s Triangle mesh generator, defaut None (no constraint)</p></li>
<li><p><strong>split_boundary</strong> (<em>bool</em>) – Whether to allow boundary segments to be splitted or not, defaut False</p></li>
<li><p><strong>plot_result</strong> (<em>bool</em>) – If True, the resulting triangulation is shown along with the input, defaut False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>raw_mesh</strong> – Output mesh, see the documentation of the triangle library</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycheeger.tools.winding">
<code class="sig-prename descclassname"><span class="pre">pycheeger.tools.</span></code><code class="sig-name descname"><span class="pre">winding</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycheeger.tools.winding" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the winding number of a closed polygonal curve described by its vertices around the point x. This number is
zero if and only if x is outside the polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em>) – Point around which the winding number is computed</p></li>
<li><p><strong>vertices</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>, </em><em>2</em><em>)</em>) – Coordinates of the curve’s vertices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wn</strong> – The winding number</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Romain Petit.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>